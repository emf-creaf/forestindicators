---
title: "Indicator estimation procedures"
author: "Miquel De Cáceres / Núria Aquilué"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Indicator estimation procedures}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(forestindicators)
```

## Introduction

In this vignette, you will learn:

  1. How to format your data for indicator estimation.
  2. How to discover which indicator functions are available, their data requirements and additional parameters.
  3. How to perform the estimation of multiple indicators at once.

## Data frame inputs

Data inputs for the estimation of indicators are data frames. Not all indicators require the same inputs, and the data frames can be of four different kinds, depending on:

 - Whether they describe *stand-level* vs. *plant-level* data
 - Whether they contain *static* vs. *dynamic* data
 
The following subsections provide examples of the four different data frames. A single indicator may only need data of one kind (e.g. plant-level dynamic data), but when calculating several indicators at once, one may end-up supplying more than one data frame.

### Stand-level static data

This data frame contains **STAND-level** information that **DOES NOT change through time**, such as topographic features, the area represented, etc. 

The actual columns will depend on the indicator to be calculated, but at least a column `id_stand` (character) should be defined to identify stands. An example of stand-level static data frame is the following:

```{r}
example_stand_static_input
```

### Stand-level dynamic data

This data frame contains **STAND-level** information that **DOES change through time**, such as temperature, precipitation, the stand leaf area index, canopy cover, etc. 

The actual columns will depend on the indicator to be calculated, but at least columns `id_stand` (character) and `date` (Date) should be defined to identify stands and time points, respectively. An example of stand-level dynamic data frame is the following:

```{r}
example_stand_dynamic_input
```


### Plant-level static data

This data frame contains **PLANT-level** information that **DOES NOT change through time**, such as taxonomy, traits, etc. 

The actual columns will depend on the indicator to be calculated, but at least a columns `id_stand` (character) and `plant_entity` (character) should be defined to identify stands and plants, respectively. An example of plant-level static data frame is the following:

```{r}
example_plant_static_input
```

### Plant-level dynamic data


This data frame contains **PLANT-level** information that **DOES change through time**, such as dbh, height, cover, etc. 

The actual columns will depend on the indicator to be calculated, but at least a columns `id_stand` (character), `plant_entity` (character) and `date` (Date) should be defined to identify stands and plants, respectively. An example of plant-level dynamic data frame is the following:

```{r}
example_plant_dynamic_input
```


## Indicators

### Indicator definition table

All the information regarding which indicators are included in the package and their requirements can be found in the data table `indicator_definition`. For each indicator, it includes:

 + Indicator name
 + Method of estimation
 + Interpretation
 + Output units
 + Person responsible of its implementation in the package, who is to be contacted in case of issues/doubts.
 + Variable names required for its estimation (grouped by input data frame)

### Variable definition table

The type and units of all input variables can be found in table `variable_definition`.

### Indicator functions

Each indicator is implemented in the package as an **internal function**, maintained by the responsible person. This functions is not directly accessible to the user, but is called via `estimate_indicators()` (see below).

### Additional parameters

The estimation of indicators may require other information in addition to the input data frame. Table `additional_parameters` contains the description of additional parameters for those functions that require them. The way these parameters are specified is described below.

## Indicator estimation procedure

The general procedure for the estimation of forest indicators follows three main steps, which we illustrate in the following subsections:

### Step 1: Choose target indicators and examine their requirements

The first step is to decide which indicators are to be estimated. The list of all indicators is given in table `indicator_definition`. Additionally, you can examine the names of the indicators in the package that could be estimated with your data by calling function `available_indicators()`:

```{r}
available_indicators(plant_dynamic_input = example_plant_dynamic_input)
```

Say we decide to estimate the *timber harvest volume* (i.e. indicator `"timber_harvest"`) and the *density of dead wood* (i.e. indicator `"density_dead_wood"`).

We may need to check which data inputs are required, their units, etc. We can find this information using function `show_information()`, for example:

```{r}
show_information("timber_harvest")
```


### Step 2: Assemble inputs and define values for additional parameters

Once the requested format and content of inputs is know, it is the responsibility of the user to build the necessary data frames to be used as inputs. In our case, we will use `example_plant_dynamic_input` that already contains the necessary data for the estimation of the two indicators.

We will normally need to define additional parameters to fine-tune the estimation of indicators, For that, we define a **named list** where each element corresponds to a different indicator and, in turn, contains a named list of parameters. In our case:

```{r}
params <- list(timber_harvest = list(province = 8),
               density_dead_wood = list(max_tree_dbh = 20))
```

### Step 3: Call general estimation function

Once we have our inputs ready, the indicators are estimated by calling function `estimate_indicators()` as follows:

```{r}
res <- estimate_indicators(indicators = c("timber_harvest", "density_dead_wood"),
                           plant_dynamic_input = example_plant_dynamic_input,
                           timber_volume_function = IFNallometry::IFNvolume_forestindicators,
                           additional_params = params)
```

Note that `"timber_harvest"` requires specifying the function to be used to calculate timber volumes, i.e. `timber_volume_function`, for which in our case we use a predefined package function.

The result of the estimation is the following:
```{r}
res
```

## Example with data from forestables

```{r}
library(forestables)
ifn_output_example
```

```{r}
ifn4_example <- ifn_output_example|>
  dplyr::filter(version == "ifn4")
```

```{r}
x <- ifn4_example |>
  dplyr::select(id_unique_code, year, province_code, tree) |>
  tidyr::unnest(cols = tree) |>
  dplyr::select("id_unique_code", "year", "province_code", "sp_name", "density_factor", "dbh", "height", "tree_ifn4") |>
  dplyr::mutate(province_code = as.numeric(province_code)) |>
  dplyr::mutate(year = as.Date(paste0(year, "-01-01"))) |>
  dplyr::rename(id_stand = id_unique_code, 
                province = province_code,
                date = year,
                n = density_factor, 
                h = height, 
                plant_entity = sp_name) |>
  dplyr::mutate(state = "live") |>
  dplyr::filter(!is.na(n)) |>
  dplyr::select(-tree_ifn4)
```


```{r}
summary(x)
```

```{r}
available_indicators(plant_dynamic_input = x)
```

```{r}
estimate_indicators(c("live_tree_density", 
                      "live_tree_basal_area",
                      "mean_tree_height",
                      "dominant_tree_height", 
                      "dominant_tree_diameter",
                      "quadratic_mean_tree_diameter",
                      "hart_becking_index"), 
                    plant_dynamic_input = x, 
                    verbose = FALSE)
```


